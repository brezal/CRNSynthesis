
DECL 
define MAX_TIME = 1;
	define SF = 1000;
	-- declare time variables
	float [0, MAX_TIME] time;
	float [0, MAX_TIME] delta_time;

	-- declare cost variables
define MAX_COST = 0; 
define NO_COST_LIMIT = 1;

	-- Define State Variables
	float[0, 1] K;
	float[0, 1] A;
	float[0, 1] B;

	-- Define Derivative Variables
	float [-4, 4] dK_dt;

	-- Lambda Variables
	float [0, 1] lamA1;
	float [0, 1] lamB1;
	float [0, 1] lamA2;
	float [0, 1] lamB2;

	-- Choice Variables
	float [0, 1] c7_1;
	float [0, 1] c7_2;

	float [0, 1] c1_0;
	float [0, 1] c1_1;
	float [0, 1] c1_2;

	float [0, 1] c4_0;
	float [0, 1] c4_1;
	float [0, 1] c4_2;

	float [0, 1] c3_0;
	float [0, 1] c3_1;
	float [0, 1] c3_2;

	float [0, 1] c6_0;
	float [0, 1] c6_1;

	float [0, 1] c5_0;
	float [0, 1] c5_1;

	float [0, 1] c2_0;
	float [0, 1] c2_1;
	float [0, 1] c2_2;


	-- Joint choice Variables
	float[0, 1] tc_1_0;
	float[0, 1] tc_1_1;

	-- Optional Reaction Variables
	float [0, 1] o0;

	-- Rate constants
	float [1, 1] k_3;
	float [0, 1] k_2;
	float [0, 1] k_1;

	--Define modes
	boole mode_1;
	boole mode_2;

INIT
	time = 0;

	-- cost condition
	(((6*c1_1 + 12*c1_2 + 5*c2_1 + 10*c2_2 + 6*c3_1 + 12*c3_2 + 5*c4_1 + 10*c4_2 + 6*c5_1*lamA2 + 6*c5_1*lamB2 + 5*c6_1*lamA2 + 5*c6_1*lamB2 + 5*c7_1*tc_1_1 + 10*c7_2*tc_1_1 + 6*lamA1 + 5*lamA2*tc_1_0 + 6*lamB1 + 5*lamB2*tc_1_0 + 9) <= MAX_COST) or (NO_COST_LIMIT = 1));

	-- cannot be in two modes at the same time. We start in mode_1.
	mode_1 = 1;
	mode_1 + mode_2 = 1;


	-- Integer encoding of lambda variables
	((lamA1 = 1) and (lamB1 = 0)) or ((lamA1 = 0) and (lamB1 = 1));
	((lamA2 = 1) and (lamB2 = 0)) or ((lamA2 = 0) and (lamB2 = 1));

	-- Integer encoding of choice variables
	 ((c7_1 = 1) and (c7_2 = 0))  or  ((c7_1 = 0) and (c7_2 = 1)) ;
	 ((c1_0 = 1) and (c1_1 = 0) and (c1_2 = 0))  or  ((c1_0 = 0) and (c1_1 = 1) and (c1_2 = 0))  or  ((c1_0 = 0) and (c1_1 = 0) and (c1_2 = 1)) ;
	 ((c4_0 = 1) and (c4_1 = 0) and (c4_2 = 0))  or  ((c4_0 = 0) and (c4_1 = 1) and (c4_2 = 0))  or  ((c4_0 = 0) and (c4_1 = 0) and (c4_2 = 1)) ;
	 ((c3_0 = 1) and (c3_1 = 0) and (c3_2 = 0))  or  ((c3_0 = 0) and (c3_1 = 1) and (c3_2 = 0))  or  ((c3_0 = 0) and (c3_1 = 0) and (c3_2 = 1)) ;
	 ((c6_0 = 1) and (c6_1 = 0))  or  ((c6_0 = 0) and (c6_1 = 1)) ;
	 ((c5_0 = 1) and (c5_1 = 0))  or  ((c5_0 = 0) and (c5_1 = 1)) ;
	 ((c2_0 = 1) and (c2_1 = 0) and (c2_2 = 0))  or  ((c2_0 = 0) and (c2_1 = 1) and (c2_2 = 0))  or  ((c2_0 = 0) and (c2_1 = 0) and (c2_2 = 1)) ;

	-- Integer encoding of optional reaction variables
	(o0 = 0) or (o0 = 1);

	-- Integer encoding of joint choice variables
	((tc_1_0 = 1) and (tc_1_1 = 0)) or ((tc_1_0 = 0) and (tc_1_1 = 1));

	-- Limits on initial conditions


TRANS 

	-- time constraint
	time' = time + delta_time;

	-- must progress through modes in order
	 mode_1' -> mode_1;
	mode_2' -> (mode_2 or mode_1);


	-- invariant conditions during modes
	mode_1  -> (dK_dt >= 0);
	mode_1'  -> (dK_dt >= 0);
	mode_2  -> (dK_dt <= 0);
	mode_2'  -> (dK_dt <= 0);

	-- jump conditions between modes
	(mode_1 and mode_2') -> (((K > 0.3) and (dK_dt < 0.001)));

	-- No state change without time consumption.
	(delta_time = 0) -> ((K' = K) and (A' = A) and (B' = B));
	(delta_time = 0) -> ((c7_1' = c7_1) and (c7_2' = c7_2));
	(delta_time = 0) -> ((c1_0' = c1_0) and (c1_1' = c1_1) and (c1_2' = c1_2));
	(delta_time = 0) -> ((c4_0' = c4_0) and (c4_1' = c4_1) and (c4_2' = c4_2));
	(delta_time = 0) -> ((c3_0' = c3_0) and (c3_1' = c3_1) and (c3_2' = c3_2));
	(delta_time = 0) -> ((c6_0' = c6_0) and (c6_1' = c6_1));
	(delta_time = 0) -> ((c5_0' = c5_0) and (c5_1' = c5_1));
	(delta_time = 0) -> ((c2_0' = c2_0) and (c2_1' = c2_1) and (c2_2' = c2_2));
	(delta_time = 0) -> ((c2_0' = c2_0) and (c2_1' = c2_1) and (c2_2' = c2_2));
	(delta_time = 0) -> ((k_3' = k_3) and (k_2' = k_2) and (k_1' = k_1));
	(delta_time = 0) -> ((o0' = o0));
	(delta_time = 0) -> ((lamA1' = lamA1) and (lamB1' = lamB1) and (lamA2' = lamA2) and (lamB2' = lamB2));


	-- Rate constants are fixed
	(d.k_3/d.time = 0);
	(k_3 = k_3');
	(d.k_2/d.time = 0);
	(k_2 = k_2');
	(d.k_1/d.time = 0);
	(k_1 = k_1');

	-- Lambda variables are fixed
	(d.lamA1/d.time = 0);
	(d.lamB1/d.time = 0);
	(lamA1 = lamA1') and (lamB1 = lamB1');
	(d.lamA2/d.time = 0);
	(d.lamB2/d.time = 0);
	(lamA2 = lamA2') and (lamB2 = lamB2');

	-- Choice variables are fixed
	(d.c7_1/d.time = 0);
	(d.c7_2/d.time = 0);
	(c7_1 = c7_1') and (c7_2 = c7_2');
	(d.c1_0/d.time = 0);
	(d.c1_1/d.time = 0);
	(d.c1_2/d.time = 0);
	(c1_0 = c1_0') and (c1_1 = c1_1') and (c1_2 = c1_2');
	(d.c4_0/d.time = 0);
	(d.c4_1/d.time = 0);
	(d.c4_2/d.time = 0);
	(c4_0 = c4_0') and (c4_1 = c4_1') and (c4_2 = c4_2');
	(d.c3_0/d.time = 0);
	(d.c3_1/d.time = 0);
	(d.c3_2/d.time = 0);
	(c3_0 = c3_0') and (c3_1 = c3_1') and (c3_2 = c3_2');
	(d.c6_0/d.time = 0);
	(d.c6_1/d.time = 0);
	(c6_0 = c6_0') and (c6_1 = c6_1');
	(d.c5_0/d.time = 0);
	(d.c5_1/d.time = 0);
	(c5_0 = c5_0') and (c5_1 = c5_1');
	(d.c2_0/d.time = 0);
	(d.c2_1/d.time = 0);
	(d.c2_2/d.time = 0);
	(c2_0 = c2_0') and (c2_1 = c2_1') and (c2_2 = c2_2');

	-- Joint choice variables are fixed
	(d.tc_1_0/d.time = 0);
	(d.tc_1_1/d.time = 0);
	(tc_1_0 = tc_1_0') and (tc_1_1 = tc_1_1');

	-- Optional reaction variables are fixed
	(d.o0/d.time = 0);
	(o0 = o0');


	-- Flows
	(mode_1 or mode_2) -> 	(d.K/d.time  = SF*(k_1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0)*(-c1_1 - 2*c1_2 + c2_1 + 2*c2_2) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(K^2*c3_2 + K*c3_1 + c3_0)*(-c3_1 - 2*c3_2 + c4_1 + 2*c4_2) + k_3*o0*(c7_1*tc_1_1 + 2*c7_2*tc_1_1)));
	(mode_1 or mode_2) -> 	(d.A/d.time  = SF*(-k_1*lamA1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamA2 + c6_1*lamA2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamA2*o0*tc_1_0));
	(mode_1 or mode_2) -> 	(dK_dt = -k_1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0)*(c1_1 + 2*c1_2 - c2_1 - 2*c2_2) - k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(K^2*c3_2 + K*c3_1 + c3_0)*(c3_1 + 2*c3_2 - c4_1 - 2*c4_2) + k_3*o0*tc_1_1*(c7_1 + 2*c7_2));
	(mode_1 or mode_2) -> 	(d.B/d.time  = SF*(-k_1*lamB1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamB2 + c6_1*lamB2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamB2*o0*tc_1_0));

TARGET 
	mode_2 and (time < 1) and (((K >= 0) and (K < 0.1)));
