
DECL 
define MAX_TIME = 1;
define THRESHOLD = 5;
	-- declare time variables
	float [0, MAX_TIME] time;
	float [0, MAX_TIME] delta_time;

	-- declare cost variables
	define MAX_COST = 100;
	define NO_COST_LIMIT = 1;

	-- Define State Variables
	float[0, 2] g;
	float[0, 2] A;
	float[0, 2] Out;
	float[0, 2] Ag;

	-- Define Derivative Variables
	float [0, 5] dOut;
	float [0, 5] ddOut;

	float [0, 4] covOut;
	float [0, 4] covg;
	float [0, 4] covA;
	float [0, 4] covAg;
	float [0, 4] covgOut;
	float [0, 4] covgA;
	float [0, 4] covAAg;
	float [0, 4] covOutAg;
	float [0, 4] covAOut;
	float [0, 4] covgAg;
        float [0, 4] covAgA;
        float [0, 4] covAgOut;
        float [0, 4] covAgg;	
	-- Rate constants
	float [0.5, 5] VA_max;
	float [0.5, 0.5] k2;
	float [0.5, 0.5] k1;
	float [0.5, 5] VB_max;
        float [0.5,0.5] vConstant;

	--Define modes
	boole mode_1;
	boole mode_2;
	boole mode_3;

INIT
	time = 0;

	-- cost condition
	(((67) <= MAX_COST) or (NO_COST_LIMIT = 1));

	-- cannot be in two modes at the same time. We start in mode_1.
	mode_1 = 1;
	mode_1 + mode_2 + mode_3 = 1;


	-- Limits on initial conditions


TRANS 

	-- time constraint
	time' = time + delta_time;

	-- must progress through modes in order
	mode_1' -> mode_1;
	mode_2' -> (mode_2 or mode_1);
	mode_3' -> (mode_3 or mode_2);


	-- invariant conditions during modes
       (mode_2) -> (covOut < THRESHOLD);	
       (mode_2') -> (covOut < THRESHOLD);

	-- jump conditions between modes
	(mode_1 and mode_2') -> (ddOut = 0);
	(mode_2 and mode_3') -> (Out > 1);
	-- No state change without time consumption.
	(delta_time = 0) -> ((Ag' = Ag) and (g' = g) and (A' = A) and (Out' = Out));
	(delta_time = 0) -> ((Ag' = Ag) and (g' = g) and (A' = A) and (Out' = Out));
	(delta_time = 0) -> ((k2' = k2) and (vConstant' = vConstant) and (k1' = k1) and (VA_max' = VA_max) and (VB_max' = VB_max));
	
	-- Rate constants are fixed
	(d.k2/d.time = 0);
	(k2 = k2');
	(d.vConstant/d.time = 0);
	(vConstant = vConstant');
	(d.k1/d.time = 0);
	(k1 = k1');
	(d.VA_max/d.time = 0);
	(VA_max = VA_max');
	(d.VB_max/d.time = 0);
	(VB_max = VB_max');


	-- Flows
	(mode_1 or mode_2 or mode_3) -> 	(d.covAgA/d.time = covA*(-A*VA_max/(A + vConstant)^2 + VA_max/(A + vConstant)) + covAg*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)) + covAgA*(Ag*VB_max/(Ag + vConstant)^2 - VB_max/(Ag + vConstant) - k1));
	(mode_1 or mode_2 or mode_3) -> 	(d.ddOut/d.time = (k1*(-A*Ag*VA_max*VB_max*(Ag + vConstant)^2 - Ag*VB_max*(A + vConstant)*(-A*VA_max*(Ag + vConstant) + Ag*VB_max*(A + vConstant) + Ag*k1*(A + vConstant)*(Ag + vConstant)) + VB_max*(A + vConstant)*(Ag + vConstant)*(-A*VA_max*(Ag + vConstant) + Ag*VB_max*(A + vConstant) + Ag*k1*(A + vConstant)*(Ag + vConstant)) + (A + vConstant)*(Ag + vConstant)^2*(Ag*VA_max*VB_max + k1*(-A*VA_max*(Ag + vConstant) + Ag*VB_max*(A + vConstant) + Ag*k1*(A + vConstant)*(Ag + vConstant)))) + k2*(A + vConstant)*(Ag + vConstant)^2*(k1*(-A*VA_max*(Ag + vConstant) + Ag*VB_max*(A + vConstant) + Ag*k1*(A + vConstant)*(Ag + vConstant)) + k2*(A + vConstant)*(Ag + vConstant)*(Ag*k1 - Out*k2)))/((A + vConstant)^2*(Ag + vConstant)^3));
	(mode_1 or mode_2 or mode_3) -> 	(d.covgOut/d.time = covAOut*(A*VA_max/(A + vConstant)^2 - VA_max/(A + vConstant)) + covAgOut*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)) + covAgg*k1 - covgOut*k2);
	(mode_1 or mode_2 or mode_3) -> 	(d.covg/d.time = 2*covAgg*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)) + 2*covgA*(A*VA_max/(A + vConstant)^2 - VA_max/(A + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.covAgOut/d.time = covAOut*(-A*VA_max/(A + vConstant)^2 + VA_max/(A + vConstant)) + covAg*k1 - covAgOut*k2 + covAgOut*(Ag*VB_max/(Ag + vConstant)^2 - VB_max/(Ag + vConstant) - k1));
	(mode_1 or mode_2 or mode_3) -> 	(d.covAgg/d.time = covAg*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)) + covAgA*(A*VA_max/(A + vConstant)^2 - VA_max/(A + vConstant)) + covAgg*(Ag*VB_max/(Ag + vConstant)^2 - VB_max/(Ag + vConstant) - k1) + covgA*(-A*VA_max/(A + vConstant)^2 + VA_max/(A + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.covgA/d.time = covA*(A*VA_max/(A + vConstant)^2 - VA_max/(A + vConstant)) + covAgA*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)) + covAgg*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.Ag/d.time = A*VA_max/(A + vConstant) - Ag*VB_max/(Ag + vConstant) - Ag*k1);
	(mode_1 or mode_2 or mode_3) -> 	(d.covA/d.time = 2*covAgA*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.A/d.time = Ag*VB_max/(Ag + vConstant));
	(mode_1 or mode_2 or mode_3) -> 	(d.Out/d.time = Ag*k1 - Out*k2);
	(mode_1 or mode_2 or mode_3) -> 	(d.dOut/d.time = -k1*(-A*VA_max/(A + vConstant) + Ag*VB_max/(Ag + vConstant) + Ag*k1) - k2*(Ag*k1 - Out*k2));
	(mode_1 or mode_2 or mode_3) -> 	(d.covAg/d.time = 2*covAg*(Ag*VB_max/(Ag + vConstant)^2 - VB_max/(Ag + vConstant) - k1) + 2*covAgA*(-A*VA_max/(A + vConstant)^2 + VA_max/(A + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.g/d.time = -A*VA_max/(A + vConstant) + Ag*VB_max/(Ag + vConstant));
	(mode_1 or mode_2 or mode_3) -> 	(d.covAOut/d.time = -covAOut*k2 + covAgA*k1 + covAgOut*(-Ag*VB_max/(Ag + vConstant)^2 + VB_max/(Ag + vConstant)));
	(mode_1 or mode_2 or mode_3) -> 	(d.covOut/d.time = 2*covAgOut*k1 - 2*covOut*k2);	


TARGET 
	mode_3 and (time < 1) ;
