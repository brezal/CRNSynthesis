
 #define MAX_TIME 1
	#define SF 1000

	// declare cost variables
	#define MAX_COST 100
	#define NO_COST_LIMIT 0

	// define derivatives
		#define dK_dt  (-k_1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0)*(c1_1 + 2*c1_2 - c2_1 - 2*c2_2) - k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(K^2*c3_2 + K*c3_1 + c3_0)*(c3_1 + 2*c3_2 - c4_1 - 2*c4_2) + k_3*o0*tc_1_1*(c7_1 + 2*c7_2))

	// declare time variables
	[0, MAX_TIME] time;

	//Define State Variables
	[0, 10] K;
	[0, 10] B;
	[0, 10] A;

	// Lambda Variables
	[0, 1] lamA1;
	[0, 1] lamB1;
	[0, 1] lamA2;
	[0, 1] lamB2;

	// Choice Variables
	[0, 1] c3_0;
	[0, 1] c3_1;
	[0, 1] c3_2;

	[0, 1] c1_0;
	[0, 1] c1_1;
	[0, 1] c1_2;

	[0, 1] c6_0;
	[0, 1] c6_1;

	[0, 1] c4_0;
	[0, 1] c4_1;
	[0, 1] c4_2;

	[0, 1] c2_0;
	[0, 1] c2_1;
	[0, 1] c2_2;

	[0, 1] c7_1;
	[0, 1] c7_2;

	[0, 1] c5_0;
	[0, 1] c5_1;


	// Joint choice Variables
	 [0, 1] tc_1_0;
	 [0, 1] tc_1_1;

	// Optional Reaction Variables
	[0, 1] o0;

	// Rate constants
	 [1, 1] k_3;
	 [0, 1] k_2;
	 [0, 1] k_1;
{ mode 1;

invt: 

	 // invariant conditions during modes
	 dK_dt >= 0;

flow: 

	 // Rate constants are fixed
	d/dt[k_3] = 0;
	d/dt[k_2] = 0;
	d/dt[k_1] = 0;

	 // Lambda variables are fixed
	d/dt[lamA1] = 0;
	d/dt[lamB1] = 0;
	d/dt[lamA2] = 0;
	d/dt[lamB2] = 0;

	 // Choice variables are fixed
	d/dt[c3_0] = 0;
	d/dt[c3_1] = 0;
	d/dt[c3_2] = 0;
	d/dt[c1_0] = 0;
	d/dt[c1_1] = 0;
	d/dt[c1_2] = 0;
	d/dt[c6_0] = 0;
	d/dt[c6_1] = 0;
	d/dt[c4_0] = 0;
	d/dt[c4_1] = 0;
	d/dt[c4_2] = 0;
	d/dt[c2_0] = 0;
	d/dt[c2_1] = 0;
	d/dt[c2_2] = 0;
	d/dt[c7_1] = 0;
	d/dt[c7_2] = 0;
	d/dt[c5_0] = 0;
	d/dt[c5_1] = 0;

	 // Joint choice variables are fixed
	d/dt[tc_1_0] = 0;
	d/dt[tc_1_1] = 0;

	 // Optional reaction variables are fixed
	d/dt[o0] = 0;


	// Flows
		d/dt[K]  = SF*(k_1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0)*(-c1_1 - 2*c1_2 + c2_1 + 2*c2_2) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(K^2*c3_2 + K*c3_1 + c3_0)*(-c3_1 - 2*c3_2 + c4_1 + 2*c4_2) + k_3*o0*(c7_1*tc_1_1 + 2*c7_2*tc_1_1));
		d/dt[A]  = SF*(-k_1*lamA1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamA2 + c6_1*lamA2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamA2*o0*tc_1_0);
		d/dt[B]  = SF*(-k_1*lamB1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamB2 + c6_1*lamB2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamB2*o0*tc_1_0);


jump: 

	 // jump conditions during modes
dK_dt >= 0 ==> @1 	 ( and (K' = K)(B' = B)(A' = A)(c3_0' = c3_0)(c3_1' = c3_1)(c3_2' = c3_2)(c1_0' = c1_0)(c1_1' = c1_1)(c1_2' = c1_2)(c6_0' = c6_0)(c6_1' = c6_1)(c4_0' = c4_0)(c4_1' = c4_1)(c4_2' = c4_2)(c2_0' = c2_0)(c2_1' = c2_1)(c2_2' = c2_2)(c7_1' = c7_1)(c7_2' = c7_2)(c5_0' = c5_0)(c5_1' = c5_1)(k_3' = k_3)(k_2' = k_2)(k_1' = k_1)(o0' = o0)(lamA1' = lamA1)(lamB1' = lamB1)(lamA2' = lamA2)(lamB2' = lamB2));


 }{ mode 2;

invt: 

	 // invariant conditions during modes
	 dK_dt <= 0;

flow: 

	 // Rate constants are fixed
	d/dt[k_3] = 0;
	d/dt[k_2] = 0;
	d/dt[k_1] = 0;

	 // Lambda variables are fixed
	d/dt[lamA1] = 0;
	d/dt[lamB1] = 0;
	d/dt[lamA2] = 0;
	d/dt[lamB2] = 0;

	 // Choice variables are fixed
	d/dt[c3_0] = 0;
	d/dt[c3_1] = 0;
	d/dt[c3_2] = 0;
	d/dt[c1_0] = 0;
	d/dt[c1_1] = 0;
	d/dt[c1_2] = 0;
	d/dt[c6_0] = 0;
	d/dt[c6_1] = 0;
	d/dt[c4_0] = 0;
	d/dt[c4_1] = 0;
	d/dt[c4_2] = 0;
	d/dt[c2_0] = 0;
	d/dt[c2_1] = 0;
	d/dt[c2_2] = 0;
	d/dt[c7_1] = 0;
	d/dt[c7_2] = 0;
	d/dt[c5_0] = 0;
	d/dt[c5_1] = 0;

	 // Joint choice variables are fixed
	d/dt[tc_1_0] = 0;
	d/dt[tc_1_1] = 0;

	 // Optional reaction variables are fixed
	d/dt[o0] = 0;


	// Flows
		d/dt[K]  = SF*(k_1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0)*(-c1_1 - 2*c1_2 + c2_1 + 2*c2_2) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(K^2*c3_2 + K*c3_1 + c3_0)*(-c3_1 - 2*c3_2 + c4_1 + 2*c4_2) + k_3*o0*(c7_1*tc_1_1 + 2*c7_2*tc_1_1));
		d/dt[A]  = SF*(-k_1*lamA1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamA2 + c6_1*lamA2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamA2*o0*tc_1_0);
		d/dt[B]  = SF*(-k_1*lamB1*(A*lamA1 + B*lamB1)*(K^2*c1_2 + K*c1_1 + c1_0) + k_2*(c5_0 + c5_1*(A*lamA2 + B*lamB2))*(-c5_1*lamB2 + c6_1*lamB2)*(K^2*c3_2 + K*c3_1 + c3_0) + k_3*lamB2*o0*tc_1_0);


jump: 

 }
init:

 @1 (and
	 // cost condition
	( (or ( (6*c1_1 + 12*c1_2 + 5*c2_1 + 10*c2_2 + 6*c3_1 + 12*c3_2 + 5*c4_1 + 10*c4_2 + 6*c5_1*lamA2 + 6*c5_1*lamB2 + 5*c6_1*lamA2 + 5*c6_1*lamB2 + 5*c7_1*tc_1_1 + 10*c7_2*tc_1_1 + 6*lamA1 + 5*lamA2*tc_1_0 + 6*lamB1 + 5*lamB2*tc_1_0 + 9) <= MAX_COST) (NO_COST_LIMIT = 1)))


	// Integer encoding of lambda variables
	 ( or ( and (lamA1 = 1)(lamB1 = 0))( and (lamA1 = 0)(lamB1 = 1)))
	 ( or ( and (lamA2 = 1)(lamB2 = 0))( and (lamA2 = 0)(lamB2 = 1)))

	 // Integer encoding of choice variables
	 ( or  ( ( and (c3_0 = 1)(c3_1 = 0)(c3_2 = 0)))   ( ( and (c3_0 = 0)(c3_1 = 1)(c3_2 = 0)))   ( ( and (c3_0 = 0)(c3_1 = 0)(c3_2 = 1))) ) 	 ( or  ( ( and (c1_0 = 1)(c1_1 = 0)(c1_2 = 0)))   ( ( and (c1_0 = 0)(c1_1 = 1)(c1_2 = 0)))   ( ( and (c1_0 = 0)(c1_1 = 0)(c1_2 = 1))) ) 	 ( or  ( ( and (c6_0 = 1)(c6_1 = 0)))   ( ( and (c6_0 = 0)(c6_1 = 1))) ) 	 ( or  ( ( and (c4_0 = 1)(c4_1 = 0)(c4_2 = 0)))   ( ( and (c4_0 = 0)(c4_1 = 1)(c4_2 = 0)))   ( ( and (c4_0 = 0)(c4_1 = 0)(c4_2 = 1))) ) 	 ( or  ( ( and (c2_0 = 1)(c2_1 = 0)(c2_2 = 0)))   ( ( and (c2_0 = 0)(c2_1 = 1)(c2_2 = 0)))   ( ( and (c2_0 = 0)(c2_1 = 0)(c2_2 = 1))) ) 	 ( or  ( ( and (c7_1 = 1)(c7_2 = 0)))   ( ( and (c7_1 = 0)(c7_2 = 1))) ) 	 ( or  ( ( and (c5_0 = 1)(c5_1 = 0)))   ( ( and (c5_0 = 0)(c5_1 = 1))) ) 
	 // Integer encoding of optional reaction variables
	(or (o0 = 0) (o0 = 1))

	 // Integer encoding of joint choice variables
	( and (tc_1_0 = 1)(tc_1_1 = 0))( or ( and (tc_1_0 = 0)(tc_1_1 = 1))) 

	 // Limits on initial conditions
);

goal: 
	@2 and ((and (K >= 0)(K < 0.1)));
